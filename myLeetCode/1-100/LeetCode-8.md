##### 一、思路

这道题是一个坑比较多的题，需要**注意输入字符串的格式**，并处理不同的情况，但总体是慢慢调试、充分考虑情况即可。

总体来说，出现的坑是这么几个：

1、**前导无效字符**。从示例中可以看到，输入的字符串并不只是由数字组成，所以先进行前导字符处理；

2、**正负号**。数字之前有可能有正负号，我用的方法是**先处理前导无效字符之后，判断是否有正负号，由此来决定符号标记flag的取值**；

3、**尾部无效字符**。不仅在字符串前面有无效字符，尾部也有，所以循环的终点并不是字符串尾，而是最后一个数字字符；

4、**数据溢出**。这个和上一道反转数字的坑是一样的，自然可以用上一道题处理溢出的方法；

**注意：**在这里编程的时候出现了一个问题，就是**三元运算符?:的优先级**。?:的优先级是很低的，只有各种赋值符号和逗号运算符的优先级比他高。如果要在表达式中使用?:，一定要注意括号的使用。

##### 二、代码

```c
//正序处理字符串转为整型 
int myAtoi(char * str){
    //找第一个非空字符并判断合法性
    int u = 0 , flag;  //flag标记结果正负
    while (str[u] == ' ')
        ++u;
    if (str[u] == '+')
    {
        ++u;
        flag = 0;
    }    
    else if (str[u] >= '0' && str[u] <= '9')
    {
        flag = 0;
    }
    else if (str[u] == '-')
    {
        flag = 1;
        ++u;
    }
    else
        return 0;
    
    // 计算结果
    int ans = 0 , single = 0;  // single为每一次处理的那一位数字
    while (str[u] >= '0' && str[u] <= '9')
    {
        single = str[u] - '0';
        
        if (flag == 0 && ((single > 7 && ans == INT_MAX / 10) || (ans > INT_MAX / 10)))  // 溢出判断
            return INT_MAX;
        if (flag == 1 && ((-single < -8 && ans == INT_MIN / 10) || (ans < INT_MIN / 10)))  // 这里出错了，因为我的ans恒正，最后才变负号..好吧不能这样子 
            return INT_MIN;
        
        //ans = ans * 10 + flag?-single:single;  //注意优先级的问题！！ 
        ans = ans * 10 + (flag?-single:single);
        u++;
    }
    return ans;
}
```

时间复杂度：**o(n)**